#version 430 core

layout(binding = 0, rgba32f) uniform image2D framebuffer;

//Uniforms

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;

struct rayObj
{
  vec3 dir;
  vec3 ori;
};

//Object types

struct material
{
  vec3 color;
};

struct box {
  vec3 min;
  vec3 max;
  material mat;
};

struct sphere{
  vec3 pos;
  float radius;
  material mat;
};


//Object definitions
#define MAX_SCENE_BOUNDS 1000.0
#define NUM_BOXES 1
#define NUM_SPHERES 2

const box boxes[] = {
  /* The ground */
 box(vec3(-5.0, -0.1, -5.0), vec3(5.0, 0.0, 5.0), material(vec3(0.7)))
  /* box in the middle */
  //{vec3(-0.5, 0.0, -0.5), vec3(0.5, 1.0, 0.5)}
};

const sphere spheres[] = {
  /* The ground */
  /* sphere in the middle */
 sphere(vec3(-0.5, 1.0, -0.5), 1.0, material(vec3(0.0, 1.0, 0.0))),
 sphere(vec3(-2.5, 1.0, -0.5), 1.0, material(vec3(1.0, 0.0, 0.0)))
};

struct hitinfo {
  vec2 lambda;
  int bi;
};

// box intersections

vec2 intersectBox(rayObj ray, const box b) {
  vec3 tMin = (b.min - ray.ori) / ray.dir;
  vec3 tMax = (b.max - ray.ori) / ray.dir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar = min(min(t2.x, t2.y), t2.z);
  return vec2(tNear, tFar);
}

bool intersectSphere(rayObj ray, const sphere s, out float t)
{
    float t_max = MAX_SCENE_BOUNDS;
    float t_min = 0;
    vec3 oc = ray.ori - s.pos;
    float a = dot(ray.dir, ray.dir);
    float b = dot(oc, ray.dir);
    float c = dot(oc, oc) - s.radius * s.radius;
    float discriminant = b * b - a * c;

    if (discriminant > 0.0)
    {
        t = (-b - sqrt(b * b - a * c)) / a;

        if (t < t_max && t > t_min)
        {
            return true;
        }

        t = (-b + sqrt(b * b - a * c)) / a;

        if (t < t_max && t > t_min)
        {
            return true;
        }
    }

    return false;
}

vec4 trace(rayObj ray) {
  vec4 color = vec4(0.0, 0.0, 0.0, 1.0);

  float tHit = MAX_SCENE_BOUNDS;
  bool found = false;
  hitinfo info;
  //Go through boxes
  for (int i = 0; i < NUM_BOXES; i++) {
    vec2 lambda = intersectBox(ray, boxes[i]);
    if (lambda.x > 0.0 && lambda.x < lambda.y && lambda.x < tHit) {
      tHit = lambda.x;
      color = vec4(boxes[i].mat.color, 1.0);
      found = true;
    }
  }
  //Go through spheres

  float t = 0;
  for (int i = 0; i < NUM_SPHERES; i++) {
    bool hit = intersectSphere(ray, spheres[i], t);
    if (hit) //Ray intersects with sphere
    {
      if (t > 0 && t < tHit) { //If it is closer than the previous intersect
        tHit = t;
        color = vec4(spheres[i].mat.color, 1.0);
        found = true;
      }
    }
  }

  if (found)
  {
    return color;
  }

  return vec4(0.0, 0.6, 0.8, 1.0); //No hit, return sky
}

layout (local_size_x = 16, local_size_y = 8) in;
void main(void) {
  ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(framebuffer);
  if (pix.x >= size.x || pix.y >= size.y) {
    return;
  }
  vec2 pos = vec2(pix) / vec2(size.x - 1, size.y - 1);
  vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
  rayObj ray = rayObj(dir, eye);
  vec4 color = trace(ray);
  imageStore(framebuffer, pix, color);
}
