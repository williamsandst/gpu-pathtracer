#version 430 core

//Uniforms
layout(binding = 0, rgba32f) uniform image2D framebuffer;

uniform samplerCube skybox;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;

//Support structs
struct rayObj
{
  vec3 dir;
  vec3 ori;
};

struct material
{
  vec4 color;
  float reflection;
  float refractiveIndex;
};

struct hitInfo
{
  float t; //Distance along ray
  int objIndex; //Normal of the hit object
  int objType; //Box 1, Sphere 2
  material mat;
};

//Object types
struct box {
  vec3 min;
  vec3 max;
  material mat;
};

struct sphere{
  vec3 pos;
  float radius;
  material mat;
};

#define FLOAT_COMPARISON_PRECISION 0.00001

//Raycasting settings
#define MAX_RAY_DEPTH 10
#define DO_REFRACTION 0  // 0 to turn off refraction
#define DO_REFLECTION 1  // 0 to turn off reflection
#define DO_FRESNEL    0  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.

//Object definitions
#define MAX_SCENE_BOUNDS 1000.0
#define NUM_BOXES 1
#define NUM_SPHERES 2
#define AMBIENT_STRENGTH 0.1
#define SPECULAR_STRENGTH 0.7
#define MIXING_FACTOR 0.7
#define BIAS 0.001

const vec3 sunLightColor = vec3(1.0, 1.0, 1.0); //Direction for the sunlight
const vec3 sunLight = normalize(vec3(1.0, 0.7, 1.0));

const box boxes[] = {
  /* The ground */
 box(vec3(-25.0, -0.5, -25.0), vec3(25.0, -0.4, 25.0), material(vec4(0.5, 0.5, 0.5, 1.0), 0, 1))
 //box(vec3(-5.2, 5.5, -5.2), vec3(4.8, 5.4, 4.8), material(vec4(0.0, 0.0, 1.0, 1.0), 0.95, 0.9))
};

const sphere spheres[] = {
  /* The ground */
  /* sphere in the middle */
 sphere(vec3(-0.5, 1.0, -0.5), 1.0, material(vec4(0.0, 0.0, 0.6, 1.0), 0.8, 1.2)),
 sphere(vec3(-10.5, 4.0, -0.5), 4.0, material(vec4(0.6, 0.0, 0.0, 1.0), 0.8, 1.2))
};


//Various functions relating to the propagation of a ray

bool fuzzy_equals(float a, float b)
{
  if (abs(a - b) < FLOAT_COMPARISON_PRECISION) return true;
  return false;
}

bool fuzzy_equals(vec3 a, vec3 b)
{
  if (fuzzy_equals(a.x, b.x) && fuzzy_equals(a.y, b.y) && fuzzy_equals(a.z, b.z)) return true;
  return false;
}

void swap(float a, float b)
{
  float temp = a;
  a = b;
  b = temp;
}

vec3 getRayPos(rayObj ray, float t)
{
  return ray.ori + ray.dir * t;
}

//Intersect functions. Determines if a ray hits a certain object.
//t is the location of the hit. Can get it as a point through the function: ray.ori + ray.dir * t

bool intersectBox(rayObj ray, const box b, out float t) {
  vec3 tMin = (b.min - ray.ori) / ray.dir;
  vec3 tMax = (b.max - ray.ori) / ray.dir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar = min(min(t2.x, t2.y), t2.z);
  if (tNear > 0.0 && tNear < tFar) //Ray hit the box
  {
    t = tNear;
    return true;
  }
  return false;
}

bool intersectSphere(rayObj ray, const sphere s, out float t)
{
    vec3 oc = ray.ori - s.pos;
    float a = dot(ray.dir, ray.dir);
    float b = dot(oc, ray.dir);
    float c = dot(oc, oc) - s.radius * s.radius;
    float discriminant = b * b - a * c;

    if (discriminant > 0.0) //Ray hit the sphere
    {
        float t1 = (-b - sqrt(b * b - a * c)) / a;
        float t2 = (-b + sqrt(b * b - a * c)) / a;

        t = min(t1, t2); //Return the closest hit

        return true;
    }

    return false;
}

vec3 sphereNormal(vec3 point, sphere s)
{
  return normalize(point - s.pos); 
}

vec3 boxNormal(vec3 point, box b) //Assuming a box fixed in the XYZ plane
{
  if (fuzzy_equals(point.x, b.min.x)) return vec3(-1, 0, 0);
  if (fuzzy_equals(point.x, b.max.x)) return vec3(1, 0, 0);
  if (fuzzy_equals(point.y, b.min.y)) return vec3(0, -1, 0);
  if (fuzzy_equals(point.y, b.max.y)) return vec3(0, 1, 0);
  if (fuzzy_equals(point.z, b.min.z)) return vec3(0, 0, -1);
  if (fuzzy_equals(point.z, b.max.z)) return vec3(0, 0, 1);
  return vec3(-1, 0, 0);
}

// Generate a random float in the range [0.0f, 1.0f] using x, y, and z (based on the xor128 algorithm)

float traceShadow(rayObj ray) //Check whether ray intersects with light source
{

  ray.dir = normalize(ray.dir);
  float t = 0;
  bool hasHit = false;

  //Check if the ray intersects with box objects
  for (int i = 0; i < NUM_BOXES; i++) {
    hasHit = intersectBox(ray, boxes[i], t); //Check if the ray hits the box
    if (hasHit && t > 0 && t < MAX_SCENE_BOUNDS) { //Is the hit closer to the camera than the previous hit?
      return 0; //Shadow!
    }
  }

  //Check if the ray intersects with sphere objects
  for (int i = 0; i < NUM_SPHERES; i++) {
    hasHit = intersectSphere(ray, spheres[i], t); //Check if the ray hits the sphere
    if (fuzzy_equals(getRayPos(ray, t), ray.ori)) continue; //Same point as the ray
    if (hasHit && t > 0 && t < MAX_SCENE_BOUNDS) { //Is the hit closer to the ray origin than the previous hit?
      return 0; //Shadow!
    }
  }

  return 1;
}

vec4 calculateLight(vec3 normal, vec3 dir, vec3 pos)
{ //Direction for the sunlight
    // ambient
    vec3 ambient = AMBIENT_STRENGTH * sunLightColor;
  	
    // diffuse 
    float diff = max(dot(normal, sunLight), 0.0);
    vec3 diffuse = diff * sunLightColor;
    
    // specular
    vec3 reflectDir = reflect(sunLight, normal);  
    float spec = pow(max(dot(dir, reflectDir), 0.0), 32);
    vec3 specular = SPECULAR_STRENGTH * spec * sunLightColor;

    //shadow
    float shadow = traceShadow(rayObj(sunLight, pos + normal * BIAS));
    
    //return vec4(1.0);
    return vec4(shadow * (diffuse + specular) + ambient, 1.0);
}

vec4 trace(rayObj ray) {
  int depth = 0;
  hitInfo skyHit = hitInfo(MAX_SCENE_BOUNDS, 0, 0, material(vec4(0.0, 0.6, 0.8, 1.0), 0, 1));
  //hitInfo skyHit = hitInfo(MAX_SCENE_BOUNDS, 0, 0, material(vec4(0.0, 0.0, 0.0, 1.0), 0));

  vec4 color;

  while (depth < MAX_RAY_DEPTH)
  {
    ray.dir = normalize(ray.dir);
    hitInfo hit, previousHit;
    hit.t = MAX_SCENE_BOUNDS;
    float t = 0;
    bool hasHit = false;
    bool hasHitTemp = false;

    //Check if the ray intersects with box objects
    for (int i = 0; i < NUM_BOXES; i++) {
      hasHitTemp = intersectBox(ray, boxes[i], t); //Check if the ray hits the box
      if (hasHitTemp && t > 0 && t < hit.t) { //Is the hit closer to the camera than the previous hit?
        hit.t = t;
        hit.mat = boxes[i].mat;
        hit.objType = 1;
        hit.objIndex = i;
        hasHit = true;
      }
    }

    //Check if the ray intersects with sphere objects
    for (int i = 0; i < NUM_SPHERES; i++) {
      hasHitTemp = intersectSphere(ray, spheres[i], t); //Check if the ray hits the sphere
      if (fuzzy_equals(getRayPos(ray, t), ray.ori)) continue; //Same point as the ray
      if (hasHitTemp && t > 0 && t < hit.t) { //Is the hit closer to the ray origin than the previous hit?
        hit.t = t;
        hit.mat = spheres[i].mat;
        hit.objType = 2;
        hit.objIndex = i;
        hasHit = true;
      }
    }

    if (hasHit) //If object is hit, calculate new ray
    {
      vec3 pos = getRayPos(ray, hit.t);
      vec3 normal;
      if (hit.objType == 1) //Box
        normal = boxNormal(pos, boxes[hit.objIndex]);
      else if (hit.objType == 2)
        normal = sphereNormal(pos, spheres[hit.objIndex]);
      if (depth == 0)
        color = hit.mat.color * calculateLight(normal, ray.dir, pos);
      else
        color = mix(color, hit.mat.color * calculateLight(normal, ray.dir, pos), MIXING_FACTOR);
      #if DO_REFLECTION
        if (hit.mat.reflection == 0)
          break;
        ray.ori = pos + BIAS * normal;
        ray.dir = reflect(ray.dir, normal);
      #endif

      #if DO_REFRACTION
        if (hit.mat.refractiveIndex == 1 && hit.mat.color.w == 1.0)
          break;
        ray.ori = pos - BIAS * normal;
        ray.dir = refract(ray.dir, normal, 1.0 / hit.mat.refractiveIndex);
      #endif

      depth = depth + 1;
      previousHit = hit;
    }
    else
    {
      if (depth == 0)
        color = texture(skybox, ray.dir);
      else
        color = mix(color, texture(skybox,ray.dir), MIXING_FACTOR);
      break;
    }
  }
  
  return color; //Return the color value of this pixel
}

layout (local_size_x = 16, local_size_y = 8) in;
void main(void) {

  ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(framebuffer);
  if (pix.x >= size.x || pix.y >= size.y) {
    return;
  }
  vec2 pos = vec2(pix) / vec2(size.x - 1, size.y - 1);
  vec3 dir = normalize(mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x));
  rayObj ray = rayObj(dir, eye);
  vec4 color = trace(ray);
  imageStore(framebuffer, pix, color);
}
